[![Open in Visual Studio Code](https://classroom.github.com/assets/open-in-vscode-2e0aaae1b6195c2367325f4f02e2d04e9abb55f0b24a779b69b11b9e10269abc.svg)](https://classroom.github.com/online_ide?assignment_repo_id=18437395&assignment_repo_type=AssignmentRepo)
# SE_Day1
Software Engineering Day1 Assignment

#Part 1: Introduction to Software Engineering

Explain what software engineering is and discuss its importance in the technology industry.

Software engineering is the systematic application of engineering principles to the design, development, testing, deployment, and maintenance of software systems. It involves a disciplined approach to solving problems and creating high-quality, reliable, and scalable software solutions.In the technology industry, software engineering is crucial because it ensures that software is developed efficiently, meets user requirements, and functions correctly under various conditions. It bridges the gap between theoretical computer science and practical application, enabling the creation of everything from mobile apps to large-scale enterprise systems. Without software engineering, the development process would be chaotic, leading to unreliable software, missed deadlines, and increased costs.



Identify and describe at least three key milestones in the evolution of software engineering.

1.The Software Crisis (1960s). As software projects grew in complexity, many failed due to poor planning, lack of methodologies, and inadequate tools. This led to the recognition of software engineering as a discipline.
2.Introduction of Structured Programming (1970s). Pioneers like Edsger Dijkstra promoted structured programming, which emphasized clear, logical, and modular code. This improved code quality and maintainability.
3.Agile Manifesto (2001).The Agile methodology revolutionized software development by prioritizing flexibility, customer collaboration, and iterative progress over rigid planning.




List and briefly explain the phases of the Software Development Life Cycle.

1. Requirements Gathering. Understanding and documenting what the software needs to do.
2. Design.  Creating blueprints for the software, including architecture and user interfaces.
3. Implementation (Coding). Writing the actual code based on the design.
4. Testing. Verifying that the software works as intended and fixing bugs.
5. Deployment. Releasing the software to users.
6. Maintenance. Updating and improving the software post-release.





Compare and contrast the Waterfall and Agile methodologies. Provide examples of scenarios where each would be appropriate.

Waterfall.  A linear, sequential approach where each phase must be completed before the next begins. It’s best for projects with well-defined requirements and minimal expected changes (e.g., building a bridge or a simple website).
Agile. An iterative approach that focuses on delivering small, functional increments of the software. It’s ideal for projects with evolving requirements (e.g., mobile apps or SaaS platforms).


Describe the roles and responsibilities of a Software Developer, a Quality Assurance Engineer, and a Project Manager in a software engineering team.

Software Developer.  Writes code, implements features, and fixes bugs. They ensure the software meets technical specifications.
Quality Assurance (QA) Engineer. Tests the software to identify defects and ensure it meets quality standards.
 Project Manager.  Oversees the project, manages timelines, resources, and communication between stakeholders.


Discuss the importance of Integrated Development Environments (IDEs) and Version Control Systems (VCS) in the software development process. Give examples of each.

IDEs. e.g. Visual Studio. Provide tools for coding, debugging, and testing in one environment, improving productivity.
VCS .e.g.Git. Track changes to code, enable collaboration, and allow developers to revert to previous versions if needed.


What are some common challenges faced by software engineers? Provide strategies to overcome these challenges.

 Changing Requirements. Use Agile methodologies to adapt quickly.
 Tight Deadlines. Prioritize tasks and use time management techniques.
 Technical Debt. Regularly refactor code to maintain quality.


Explain the different types of testing (unit, integration, system, and acceptance) and their importance in software quality assurance.

Unit Testing. Tests individual components or functions (e.g., testing a login function).
Integration Testing. Ensures different modules work together (e.g., testing how the login interacts with the database).
System Testing. Validates the entire system against requirements.
Acceptance Testing. Confirms the software meets user needs and is ready for release.


#Part 2: Introduction to AI and Prompt Engineering


Define prompt engineering and discuss its importance in interacting with AI models.

Prompt engineering is the art of crafting effective inputs (prompts) to guide AI models, like ChatGPT, to produce desired outputs. It’s important because well-designed prompts can improve the accuracy, relevance, and usefulness of AI responses. Poorly designed prompts may lead to vague or irrelevant answers.


Provide an example of a vague prompt and then improve it by making it clear, specific, and concise. Explain why the improved prompt is more effective.

Vague Prompt. "Tell me about history."
Improved Prompt. "Explain the causes and consequences of the Mau Mau Revolution in 3-4 concise paragraphs."
Why It’s Better.  The improved prompt is specific, clear, and sets boundaries, making it easier for the AI to provide a focused and relevant response.


